package edu.iastate.summer18.cs228.hw7;import java.awt.Point;import java.util.ArrayList;/** * A class that implements a "2-dimensional kd-tree", or 2d-tree. * * @author Robert Shay */public class Tree2D<T extends Point> implements TreeInterface<T> {	private BinaryNode<T> root;		public Tree2D() {		root = null;	} // end default constructor		public Tree2D(T rootData) {		root = new BinaryNode<>(rootData);	} // end constructor		public Tree2D(T rootData, Tree2D<T> leftTree, Tree2D<T> rightTree) {		privateSetTree(rootData, leftTree, rightTree);	} // end constructor		// Given an array of points initializes this object	// by adding all points in array into this tree.	public Tree2D(T[] arr) {		this();		if (arr == null || arr.length == 0) throw new IllegalArgumentException();		for (T d : arr)			addPoint(d);	} // end constructor		// Returns inorder traversal of points' X coordinates in this tree.	// If tree is empty then null is returned.	public double[] inorderX() {		if (isEmpty()) return null;		ArrayList<Point> arr = new ArrayList<>();		recInorder(arr, root);		double[] r = new double[arr.size()];		int i = 0;		for (Point p : arr) {			r[i] = p.getX();			i++;		}		return r;	}		// Returns inorder traversal of points' Y coordinates in this tree.	// If tree is empty then null is returned.	public double[] inorderY() {		if (isEmpty()) return null;		ArrayList<Point> arr = new ArrayList<>();		recInorder(arr, root);		double[] r = new double[arr.size()];		int i = 0;		for (Point p : arr) {			r[i] = p.getY();			i++;		}		return r;	}		/**	 * Adds the nodes from the tree recusively in an in order traverse.	 * 	 * @param arr	 * @param node	 */	private void recInorder(ArrayList<Point> arr, BinaryNode<T> node) {		if (node == null) return;		recInorder(arr, node.getLeftChild());		arr.add(node.getData());		recInorder(arr, node.getRightChild());	}		public void setTree(T rootData) {		root = new BinaryNode<>(rootData);	} // end setTree		public void setTree(T rootData, TreeInterface<T> leftTree, TreeInterface<T> rightTree) {		privateSetTree(rootData, (Tree2D<T>) leftTree, (Tree2D<T>) rightTree);	} // end setTree		/**	 * Adds a new point into the 2d-tree.	 * 	 * @param anEntry	 *            The new point to add into the tree.	 */	public void addPoint(T anEntry) {		if (anEntry == null) return;		if (root == null) root = new BinaryNode<T>(anEntry);		else add(getRootNode(), anEntry, 1);	} // end addPoint		/**	 * Recursive method used to add new data to the tree.	 * 	 * @param node	 * @param e	 * @param level	 */	private void add(BinaryNode<T> node, T e, int level) {		if (level % 2 == 1) {			if (node.getData().getX() > e.getX()) {				if (node.hasLeftChild()) add(node.getLeftChild(), e, level + 1);				else node.setLeftChild(new BinaryNode<T>(e));			}			else {				if (node.hasRightChild()) add(node.getRightChild(), e, level + 1);				else node.setRightChild(new BinaryNode<T>(e));			}		}		else {			if (node.getData().getY() > e.getY()) {				if (node.hasLeftChild()) add(node.getLeftChild(), e, level + 1);				else node.setLeftChild(new BinaryNode<T>(e));			}			else {				if (node.hasRightChild()) add(node.getRightChild(), e, level + 1);				else node.setRightChild(new BinaryNode<T>(e));			}		}			}		// Used to find whether the current tree contains the inputed data. True is	// returned if it does.	public boolean contains(T anEntry) {		if(root == null) return false;		return find(root.copy(), anEntry, 1);	} // end contains		/**	 * Recursive method to find the inputed data.	 * 	 * @param aNode	 * @param anEntry	 * @param level	 * @return The node that has a matching entry, null if not.	 */	private boolean find(BinaryNode<T> aNode, T anEntry, int level) {		if (anEntry == null) return false;		T data = aNode.getData();		if (anEntry.getX() == data.getX() && anEntry.getY() == data.getY()) return true;				if (level % 2 == 1) {			if (data.getX() > anEntry.getX() && aNode.hasLeftChild()) return find(aNode.getLeftChild(), anEntry, level + 1);			else if (aNode.hasRightChild()) return find(aNode.getRightChild(), anEntry, level + 1);		}		else {			if (data.getY() > anEntry.getY() && aNode.hasLeftChild()) return find(aNode.getLeftChild(), anEntry, level + 1);			else if (aNode.hasRightChild()) return find(aNode.getRightChild(), anEntry, level + 1);		}		return false;	}		private void privateSetTree(T rootData, Tree2D<T> leftTree, Tree2D<T> rightTree) {		root = new BinaryNode<T>(rootData);				if (leftTree != null && !leftTree.isEmpty()) root.setLeftChild(leftTree.root);				if (rightTree != null && !rightTree.isEmpty()) {			if (rightTree != leftTree) root.setRightChild(rightTree.root);			else root.setRightChild(rightTree.root.copy());		} // end if				if (leftTree != null && leftTree != this) leftTree.clear();				if (rightTree != null && rightTree != this) rightTree.clear();	} // end privateSetTree		public T getRootData() {		if (isEmpty()) throw new EmptyTreeException();		else return root.getData();	} // end getRootData		public boolean isEmpty() {		return root == null;	} // end isEmpty		public void clear() {		root = null;	} // end clear		protected void setRootData(T rootData) {		root.setData(rootData);	} // end setRootData		protected void setRootNode(BinaryNode<T> rootNode) {		root = rootNode;	} // end setRootNode		protected BinaryNode<T> getRootNode() {		return root;	} // end getRootNode		public int getHeight() {		return root.getHeight();	} // end getHeight		public int getNumberOfNodes() {		return root.getNumberOfNodes();	} // end getNumberOfNodes} // end Tree2D